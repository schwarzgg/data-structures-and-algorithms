const int maxn = 1e4+3;

struct Node // 邻接表存图
{
    int v,w; // v:图的可达点，w：u-v的权值；
};

struct node  // 最短路
{
    int dis,u; // dis:距离，u:顶点
    
    // 运算符重载（使优先队列可用）
    bool operator > (const node& a) const{
        return dis > a.dis;
    }
};

vector<Node>v[maxn]; // 邻接表
int dis[maxn];// 距离（最短路）
int vis[maxn];// 访问标记

void init(int t) // 初始化存图
{
    while (t--)
    {
        int a,b,c;cin >> a >> b >> c;
        v[a].push_back({b,c});
        v[b].push_back({a,c});
    }
}

void dijkstra(int s) // Dijkstra
{
    memset(dis ,0x3f ,sizeof(dis)); //初始化数组dis内的值为无穷大
    memset(vis ,0 ,sizeof(vis));
    
    priority_queue< node ,vector<node> ,greater<node> >q;
    q.push({0 ,s});
    dis[s] = 0;
    
    while (q.size())
    {
        int u = q.top().u;
        q.pop();
        
        if (vis[u]) continue; // 该点已被访问，则跳过
        vis[u] = 1;
        
        for (int i = 0 ;i < v[u].size() ;i++) // 对该顶点的可达点进行遍历
        {
            int v = v[u][i].v;
            int w = v[u][i].w;
            
            if (dis[v] > dis[u] + w) // 如果到达当前点u的距离+ w:(u-v) > 到达当前点v的距离，则进行更新操作
            {
                dis[v] = dis[u] + w; // 更新
                q.push({dis[v] ,v});
            }
        }
    }
}
