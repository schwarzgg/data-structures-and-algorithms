// 并查集 && 相关操作

const int maxn = 1e4 + 3;

int f[maxn]; // 并查集
int vis[maxn]; // 每个元素的秩（合并）

void init(int n) // 初始化并查集
{
    for (int i=1;i<=n;i++)
        f[i] = i,vis[i] = 0;
}

int find(int x) // 查找（路径压缩）
{
    if (x == f[x]) return f[x]; // 查找 x 的祖先直到找到代表，于是顺手路径压缩
    else return f[x] = find(f[x]); // x 不是自身的父亲，即 x 不是该集合的代表
}

void build (int x,int y) // 按秩合并
{
    int dx=find(dx);
    int dy=find(dy);
    
    if (vis[dx] == vis[dy])
        vis[dx]++,f[dy]=dx;
    else
        vis[dx] < vis[dy] ? f[dx] = dy : f[dy] = dx;
}

/* 以下代码为普通合并，即不需要进行按秩合并的操作

void build (int x,int y)
{
    int dx=find(x);
    int dy=find(y);
    
    f[dx]=dy;
}
*/

int count_set(int n) // 并查集中存在多少个不同的集合
{
    int ans=0;
    for (int i=1;i<=n;i++)
        if (find[i] == i)
            ans++;
    return ans;
}







